# Provenance Marks: Forward-Secure Commitment-Revealing Hash Chains with Sequential Disclosure

Wolf McNallyÂ¹ and Christopher AllenÂ¹

Â¹Blockchain Commons\
{wolf,christophera}@blockchaincommons.com

**Date:** January 2025\
**Subject:** Cryptography and Security (cs.CR)\
**Keywords:** hash chains, forward security, commitment schemes, provenance, authentication

## Abstract

Unlike Lamport-style hash chainsâ€”which are generated by forward hashing but revealed backwardâ€”and blockchainsâ€”which link backward to prior blocks and do not pre-commit to future onesâ€”each link in a Provenance Marks (PM) chain pre-commits to the next value: it binds an unrevealed next key that is opened later. This provides forward security (past keys donâ€™t compromise future ones), proof of authentic generation (only the original generator knows the pre-committed values), and enables controlled rotation by revealing the next pre-committed key to a new party. Concretely, at step $j$ the link stores a commitment $c_j = H(k_{j+1})$; at step $j+1$ it reveals $k_{j+1}$, and verifiers check $H(k_{j+1}) = c_j$. We present this work as protocol designers seeking cryptographic review of our construction.


## 1. Introduction

Hash chains have been a fundamental cryptographic primitive since Lamport's seminal work on one-time passwords [1]. Traditional hash chains work by iteratively hashing: given a value $v_i$, the next value is computed as $v_{i+1} = H(v_i)$. This construction has found widespread use in authentication protocols, time-stamping systems, and hash-chained data structures (e.g., blockchains).

However, traditional hash chains have limitations:

- **Post-hoc generation**: Anyone with knowledge of $v_i$ can compute the entire forward chain
- **No forward security**: Compromise of the current state allows generation of all future states
- **Limited transferability**: Secure handoff to a new party requires additional protocols

We present Provenance Marks (PM), a variant of hash chains that addresses these limitations through a commitment-revealing structure. In PM chains, the generator derives the next random value but reveals it in controlled fashion, with each link committing to (but not revealing) the next.

### 1.1 Our Contributions

1. We introduce the Provenance Marks (PM) construction: a commitment-revealing hash chain where each link commits to the next key. PM provides forward security of keys (next-key unpredictability) and post-lock tamper-evidence; we specify both a minimal scheme and an implementation-backed context-binding variant that also locks metadata.
2. We give security definitions and ROM bounds for next-key unpredictability and unforgeability (from second-preimage resistance), and we spell out limitations (pre-lock mutability of metadata under the minimal scheme, non-exclusive handoff without an external protocol).
3. We compare PM to Lamport chains, blockchains/Certificate Transparency, VDFs, and hash-based signatures, and identify where PMâ€™s forward pre-commitment and controlled handoff are advantageous.
4. We outline applications that benefit from these properties.

**Disclaimer.** We provide proof sketches and bounds in the random-oracle model; standard-model proofs and tighter bounds are open problems. Immutability of per-link metadata at publication time requires either the context-binding variant or external anchoring (e.g., transparency logs).


## 2. Related Work

**Hash Chains and One-Time Passwords**: Lamport [1] introduced hash chains for password authentication. The S/KEY system [2] popularized this approach. Jakobsson [3] improved traversal efficiency with fractal representations. These systems typically use backward revelation: starting from $H^n(s)$ and revealing pre-images sequentially.

**Forward Security**: Bellare and Miner [4] formalized forward security for digital signatures. Anderson [5] explored forward security in various contexts. Our construction provides forward security in a different sense: compromise of revealed keys provides no advantage in predicting future unrevealed keys.

**Commitment Schemes**: Our construction can be viewed as a chain of commitments. Pedersen commitments [6] provide information-theoretic hiding. Halevi and Micali [7] showed practical commitments from collision-resistant hashing. We use the random oracle model where $H(k)$ serves as a perfectly binding commitment to $k$.

**Time-Stamping and Certificate Transparency**: Haber and Stornetta [8] introduced cryptographic time-stamping. Certificate Transparency [9] uses Merkle trees for auditability. While both create verifiable sequences, PM chains uniquely combine forward security with transferability.

**Hash-Based Signatures**: XMSS [10] and SPHINCS+ [11] use hash chains for quantum-resistant signatures. PM chains share the stateful nature but serve different purposes.

**Verifiable Delay Functions**: VDFs [12] force computational delay before output. PM chains differ by allowing immediate revelation at the holder's discretion.

## 3. Preliminaries

### 3.1 Notation

- $\lambda$ denotes the security parameter
- $H: \{0,1\}^* \rightarrow \{0,1\}^\ell$ denotes a cryptographic hash function with $\ell$-bit output
- $x \leftarrow_R S$ denotes uniform random sampling from set $S$
- $x \leftarrow A$ denotes assignment of output of algorithm $A$ to $x$
- $||$ denotes concatenation
- $[n]$ denotes the set $\{0, 1, ..., n-1\}$
- PPT denotes probabilistic polynomial time

### 3.2 Security Assumptions

We work in the random oracle model, treating $H$ as a random oracle. Our security arguments rely on:

**Definition 1 (Preimage Resistance)**: A hash function $H$ is preimage resistant if for all PPT adversaries $\mathcal{A}$:
$$\Pr[x \leftarrow \mathcal{A}(y) : H(x) = y] \leq \text{negl}(\lambda)$$
where $y \leftarrow_R \{0,1\}^\ell$.

**Definition 2 (Second Preimage Resistance)**: A hash function $H$ is second preimage resistant if for all PPT adversaries $\mathcal{A}$ and all $x_1$:
$$\Pr[x_2 \leftarrow \mathcal{A}(x_1) : x_2 \neq x_1 \wedge H(x_2) = H(x_1)] \leq \text{negl}(\lambda)$$

### 3.3 Traditional Hash Chains

**Definition 3 (Traditional Hash Chain)**: A traditional hash chain of length $n$ is generated as:
- Choose seed $s \leftarrow_R \{0,1\}^\ell$
- Compute $v_0 = s$, and $v_{i+1} = H(v_i)$ for $i \in [n-1]$

Verification proceeds forward: given $v_i$, check that $v_{i+1} = H(v_i)$.

## 4. The Provenance Mark Construction

### 4.1 Formal Definition

**Definition 4 (Provenance Mark Chain)**: A PM chain of length $n$ is a tuple $(\mathsf{ID}, K, H, L)$ where:
- $\mathsf{ID} \in \{0,1\}^\ell$ is a globally-unique chain identifier
- $K = (k_0, ..., k_{n-1})$ where each $k_i \leftarrow_R \{0,1\}^\ell$ and **$k_0 = \mathsf{ID}$ (genesis)**
- $H = (\text{hash}_0, ..., \text{hash}_{n-2})$ where $\text{hash}_i = H(k_i || k_{i+1} || \mathsf{ID} || \text{seq}_i || \text{date}_i || \text{info}_i)$
- $L = (L_0, ..., L_{n-1})$ where $L_j = (j, k_j, \text{hash}_j, \text{seq}_j, \text{date}_j, \text{info}_j)$ for $j < n-1$, and $L_{n-1} = (n-1, k_{n-1}, \perp, \text{seq}_{n-1}, \text{date}_{n-1}, \text{info}_{n-1})$

### 4.2 Algorithms

**Algorithm 1: $\mathsf{PM.Gen}(1^\lambda, n)$**

```
Input: Security parameter Î», chain length n
Output: Chain identifier ID, secret keys K, initial commitment hashâ‚€

1: for i = 0 to n-1 do
2:    k_i â†_R {0,1}^â„“
3: end for
4: set ð™„ð˜¿ â† kâ‚€          // genesis fixes kâ‚€ to be the chain identifier
5: for i = 0 to n-2 do
6:    hash_i â† H(k_i || k_{i+1} || ð™„ð˜¿ || seq_i || date_i || info_i)
7: end for
8: return (ð™„ð˜¿, K, hashâ‚€)
```

**Algorithm 2: $\mathsf{PM.Reveal}(k_j, \text{hash}_j, \text{seq}_j, \text{date}_j, \text{info}_j)$**

```
Input: Key k_j, commitment hash_j, sequence seq_j, date date_j, metadata info_j
Output: Link L_j

1: L_j â† (j, k_j, hash_j, seq_j, date_j, info_j)
2: return L_j
```

**Algorithm 3: $\mathsf{PM.Verify}(L_0, ..., L_j, ð™„ð˜¿)$**

```
Input: Links Lâ‚€ through L_j, agreed chain identifier ð™„ð˜¿
Output: {accept, reject}

1: Parse Lâ‚€ as (0, kâ‚€, hashâ‚€, seqâ‚€, dateâ‚€, infoâ‚€)
2: if kâ‚€ â‰  ð™„ð˜¿ or seqâ‚€ â‰  0 then return reject
3: for i = 1 to j do
4:    Parse L_{i-1} as (i-1, k_{i-1}, hash_{i-1}, seq_{i-1}, date_{i-1}, info_{i-1})
5:    Parse L_i as (i, k_i, hash_i, seq_i, date_i, info_i)
6:    if H(k_{i-1} || k_i || ð™„ð˜¿ || seq_{i-1} || date_{i-1} || info_{i-1}) â‰  hash_{i-1} then return reject
7:    if seq_i â‰  seq_{i-1} + 1 then return reject
8:    if date_i < date_{i-1} then return reject
9: end for
10: return accept
```

### 4.3 Security Properties

### 4.4 Genesis & Parameters (recommended)

In the reference implementation, the chain identifier `chain_id` is derived from a secret seed and the genesis key is set equal to this `chain_id`. Verifiers MUST REQUIRE the genesis link to satisfy `(seq = 0) âˆ§ (k_0 = chain_id)`.

The construction provides:

1. **Forward Security**: Past key compromises don't affect future unrevealed keys
2. **Authenticity**: Only the key holder can extend the chain
3. **Tamper-evidence (post-lock)**: Once a subsequent link is published, any change to prior links that affects fields covered by commitments becomes detectable. Under the minimal scheme with $c_i = H(k_{i+1})$, only the keys are locked; metadata such as dates or `info` remain mutable until locked by a later link or anchored externally.
4. **Transferability**: Holders can hand off the ability to extend by one step by revealing the next pre-committed key; exclusive control requires additional protocol.

## 5. Security Analysis

### 5.1 Security Definitions

**Definition 5 (Next-Key Unpredictability for PM)**: A PM scheme has next-key unpredictability if for all PPT adversaries $\mathcal{A}$ the probability of outputting the unrevealed next key is negligible:
$$\Pr[\mathsf{NKU}_{\mathcal{A}}(\lambda) = 1] \leq \text{negl}(\lambda)$$

where the experiment $\mathsf{NKU}_{\mathcal{A}}(\lambda)$ is defined as:

```
1: (ð™„ð˜¿, K, hashâ‚€) â† PM.Gen(1^Î», n)
2: j* â† Aâ‚(n)  // adversary chooses compromise point
3: Give Aâ‚‚ keys (kâ‚€, ..., k_{j*}) and all commitments (hashâ‚€, ..., hash_{n-2})
4: kÌ‚ â† Aâ‚‚(1^Î»)  // adversary outputs a candidate for k_{j*+1}
5: return (kÌ‚ = k_{j*+1})
```

*Remark (Indistinguishability caveat).* Because commitments are public, any distinguisher given a challenge value $x$ can query $H(x)$ and test if it equals the relevant hash; therefore $k_{j*+1}$ is not indistinguishable from uniform given oracle access and public commitments. The right notion here is unpredictability/preimage hardness, not indistinguishability.

### 5.2 Security Theorems

**Theorem 1 (Next-Key Unpredictability)**: In the random oracle model, the PM construction achieves next-key unpredictability. Specifically, for any PPT adversary $\mathcal{A}$ making at most $q_H$ queries to the random oracle,
$$\Pr[\mathsf{NKU}_{\mathcal{A}}(\lambda) = 1] \leq \frac{q_H}{2^\ell}.$$

*Proof sketch*: The only winning strategy is to query the random oracle on the exact value $k_{j*+1}$. Since $k_{j*+1}$ is uniform and hidden behind its hash commitment, each query hits with probability $2^{-\ell}$, for a total advantage of at most $q_H/2^\ell$. â–¡

**Theorem 2 (Unforgeability)**: Assuming $H$ is second preimage resistant, no PPT adversary can produce a valid alternate link. Formally, for all PPT adversaries $\mathcal{A}$:
$$\Pr[\mathsf{Forge}_{\mathcal{A}}(\lambda) = 1] \leq \text{negl}(\lambda)$$

where $\mathsf{Forge}_{\mathcal{A}}$ outputs 1 iff $\mathcal{A}$ produces $L'_j \neq L_j$ that passes verification.

*Proof sketch*: A valid alternate link requires finding $k'_j \neq k_j$ with the same commitment as $L_{j-1}$, violating second preimage resistance for $H$. â–¡

## 6. Efficiency Analysis

### 6.1 Computational Costs

| Operation | Hash Operations | Storage |
|-----------|----------------|---------|
| Generation | $n - 1$ | $n \cdot \ell$ bits |
| Reveal step $j$ | 0 | $O(1)$ |
| Verify $j$ steps | $j$ | $O(j)$ |

### 6.2 Comparison with Other Schemes

| Property | Traditional Hash Chain | Provenance Marks | VDF-based | Certificate Transparency |
|----------|----------------------|------------------|-----------|------------------------|
| Generation | Backward: $O(n)$ hash | Forward: $O(n)$ hash + $n$ random | $O(n)$ sequential | $O(\log n)$ tree |
| Storage | $O(1)$ | $O(n)$ | $O(1)$ | $O(n)$ |
| Forward Security | No | Yes | Yes | Partial |
| Transferability | Complex | Simple hand-off (non-exclusive) | No | No |
| Verification | $O(j)$ | $O(j)$ | $O(T)$ time | $O(\log n)$ |

### 6.3 Practical Security Parameters

For different security levels, we recommend:
- **128-bit security**: Use $\ell = 256$ (SHA-256)
- **256-bit security**: Use $\ell = 512$ (SHA-512)

Post-quantum security: The construction appears quantum-safe as it relies only on hash function properties, requiring approximately $\sqrt{2^\ell}$ quantum operations to break.

**Note on threshold variant**: While the basic PM construction requires secure key storage, our companion work [13] presents FROST-PM, which eliminates this requirement through threshold cryptography, allowing distributed generation without any party holding the complete key sequence.

## 7. Implementation Security Considerations

### 7.1 Random Number Generation

Keys must be generated using cryptographically secure random number generators (CSPRNG/DRBG). Non-cryptographic PRNGs can make future keys predictable and break next-key unpredictability.

### 7.2 Key Storage

Secret keys $(k_0, ..., k_{n-1})$ require secure storage. Hardware security modules (HSMs) or secure enclaves are recommended for high-value applications.

### 7.3 Side-Channel Resistance

Implementations SHOULD use constant-time operations for key comparisons and avoid timing-based leaks during revelation.

### 7.4 Handover and Race Conditions (recommended)

Revealing $k_{j+1}$ transfers the *ability* to extend the chain by one step, but it does not prevent the previous holder from racing to publish $L_{j+1}$. Applications MAY use an authenticated side channel (e.g., signatures) or threshold control to ensure exclusive continuation.

### 7.5 Key Derivation / PRNG State (recommended)

If keys are derived online from a PRNG/DRBG instead of precomputing $K$, use a cryptographically secure DRBG with **backtracking resistance** and that overwrites its internal state (e.g., HMAC-/HKDF-based designs). Avoid persisting raw generator state.

If an attacker learns the generator state at step $j$, they can derive and publish subsequent keys and thus extend the current chain. A better DRBG does not prevent that; it only protects past keys from reconstruction (backtracking) and aids recovery once you reseed and move to a new chain. To regain exclusive control after suspected compromise, close/rotate the current chain (start a new `chain_id`, optionally with a signed rotation mark) or adopt threshold-controlled next-key derivation (e.g., FROSTâ€‘PM).

### 7.6 Encoding Conventions (recommended)

Adopt canonical byte encodings (e.g., big-endian for counters) and length-prefix all variable fields before hashing. Publish these parameter choices with the chain so independent implementations interoperate. The reference implementation uses fixed-length encodings for all fields except `info`.

### 7.7 Publication & Audit (recommended)

Per-link immutability **before** the next link exists requires external anchoring. To deter undetectable revisions, publish each mark to an append-only transparency log (e.g., Merkle-tree log with Signed Tree Heads), a time-stamping service, or a blockchain anchor, and let verifiers audit inclusion/consistency proofs. Otherwise, detection relies on observers retaining previous versions of the chain.

## 8. Extensions and Variants

### 8.1 Variable-Length Commitments

The construction extends naturally to different commitment lengths by truncating hash outputs. This trades off security for efficiency in applications where collision resistance is less critical than compactness.

### 8.2 Metadata Binding

Additional authenticated data can be bound to each link by including it in the state update: $S_{j+1} = H(S_j || k_j || \text{metadata}_j)$.

### 8.3 Parallel Chains

Multiple independent chains can be managed by a single entity using domain separation: different genesis values or prefixes for each chain.

### 8.4 Context-Binding Commitments (reference implementation)

In the reference implementation, each link stores a commitment `hash` computed as:

$$
\text{hash}_i = H(\, k_i \; || \; k_{i+1} \; || \; \mathsf{ID} \; || \; \text{seq}_i \; || \; \text{date}_i \; || \; \text{info}_i \,)
$$

This is strictly stronger than the minimal scheme $c_i = H(k_{i+1})$ because it binds the chain identifier, sequence number, timestamp, and optional metadata to the commitment.

### 8.5 Optional Domain Separation (recommended)

Although the reference implementation does **not** hash string domain-separation tags like "genesis", deployments MAY add fixed ASCII labels and length-prefixing to all encodings for additional hardening, provided all parties agree on the format.

### 8.6 Hidden-Metadata Option

When metadata must remain private until a later revelation, include a hidden commitment $m_j = H(\text{metadata}_j || r_j)$ inside $L_j$ and later reveal $(\text{metadata}_j, r_j)$. Verifiers then check the opening against $m_j$.

## 9. Applications

While detailed applications are beyond our scope, PM chains are suitable for:
- **Supply chain tracking**: Each party reveals their link when transferring goods
- **Audit logs**: Forward-secure logs where past entries can't be forged
- **Key rotation ceremonies**: Controlled handover with cryptographic evidence
- **Digital rights management**: Sequential revelation of access keys

## 10. Future Work

Beyond the theoretical questions posed below, we are developing:
- **Threshold variant**: A seedless construction using threshold cryptography (FROST) to eliminate single points of failure while maintaining deterministic key generation. See our companion paper "FROST-PM: Seedless Threshold Provenance Marks via Group-Controlled VRFs" [13] for details.
- **Implementation standards**: Reference implementations and data format specifications
- **Integration protocols**: Concrete protocols for PM chains in existing systems

## 11. Open Questions

We invite the cryptographic community to investigate:

1. **Formal security proofs** in the standard model (without random oracles)
2. **Tight security bounds** for the advantage of adversaries
3. **Lower bounds** on storage requirements for forward-secure chains
4. **Optimal chain traversal** algorithms for very long chains
5. **Composition** with other cryptographic protocols

## 12. Implementation and Availability

Reference implementations and specifications are publicly available:
- Project page: https://provemark.com
- Technical specification: https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2025-001-provenance-mark.md
- Reference implementations in Rust and Swift: https://github.com/BlockchainCommons/provenance-mark-rust and https://github.com/BlockchainCommons/Provenance
- Command-line tools: https://github.com/BlockchainCommons/provenance-mark-cli-rust

We encourage researchers to examine these implementations when analyzing the construction.

## 13. Conclusion

Provenance Marks provide a simple yet powerful extension to traditional hash chains. By pre-committing to future values without revealing them, PM chains achieve forward security, authentic generation proofs, and controlled transferability. The construction requires only a cryptographic hash function and random sampling.

We present this work to the cryptographic community for review and analysis. While we believe the construction is sound, formal security analysis would strengthen confidence in deployment. We particularly seek feedback on potential vulnerabilities or attacks we may have overlooked.

## Acknowledgments

We thank the Blockchain Commons community for discussions leading to this work. This research was supported in part by donations to Blockchain Commons.

## References

[1] Lamport, L. (1981). Password authentication with insecure communication. *Communications of the ACM*, 24(11), 770-772.

[2] Haller, N. (1995). The S/KEY one-time password system. RFC 1760.

[3] Jakobsson, M. (2002). Fractal hash sequence representation and traversal. In *IEEE Symposium on Security and Privacy* (pp. 437-444).

[4] Bellare, M., & Miner, S. K. (1999). A forward-secure digital signature scheme. In *Annual International Cryptology Conference* (pp. 431-448). Springer.

[5] Anderson, R. (1997). Two remarks on public key cryptology. *Technical Report*, University of Cambridge.

[6] Pedersen, T. P. (1991). Non-interactive and information-theoretic secure verifiable secret sharing. In *Annual International Cryptology Conference* (pp. 129-140). Springer.

[7] Halevi, S., & Micali, S. (1996). Practical and provably-secure commitment schemes from collision-free hashing. In *Advances in Cryptologyâ€”CRYPTO'96* (pp. 201-215).

[8] Haber, S., & Stornetta, W. S. (1991). How to time-stamp a digital document. In *Conference on the Theory and Application of Cryptography* (pp. 437-455). Springer.

[9] Laurie, B., Langley, A., & Kasper, E. (2013). Certificate transparency. RFC 6962.

[10] Buchmann, J., Dahmen, E., & HÃ¼lsing, A. (2011). XMSS - A practical forward secure signature scheme based on minimal security assumptions. In *Post-Quantum Cryptography* (pp. 117-129).

[11] Bernstein, D. J., et al. (2019). SPHINCS+. *NIST Post-Quantum Cryptography Standardization*.

[12] Boneh, D., Bonneau, J., BÃ¼nz, B., & Fisch, B. (2018). Verifiable delay functions. In *Annual International Cryptology Conference* (pp. 757-788). Springer.

[13] McNally, W., & Allen, C. (2025). FROST-PM: Seedless Threshold Provenance Marks via Group-Controlled VRFs. *arXiv preprint* (companion paper).
